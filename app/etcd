#!/bin/bash

#
# Copyright (C) 2018 Heinrich-Heine-Universitaet Duesseldorf, Institute of Computer Science, Department Operating Systems
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
__ETCD_PATH=""
__ETCD_OUT_PATH=""
__ETCD_PEER_PORT=2380
__ETCD_CLIENT_PORT=2379

readonly __ETCD_DATA_DIR="/tmp/etcd"

cdepl_app_etcd_init()
{
	local path=$1

	__ETCD_PATH="$(cdepl_cluster_node_cmd 0 "readlink -f $path")"
	__ETCD_OUT_PATH="$(cdepl_run_get_cur_out_path)/etcd"

	if [ ! "$__ETCD_PATH" ] || [ "$(cdepl_cluster_file_system_cmd "[ -d $__ETCD_PATH ] && echo \"1\"")" != "1" ]; then
		util_log_error_and_exit "[etcd]: Path does not exist ($path), resolved path: $__ETCD_PATH"
	fi

	util_log "[etcd] Initialized: $__ETCD_PATH"
	util_log "[etcd] Output: $__ETCD_OUT_PATH"
}

##
# Start consul instances on the target nodes.
#
# $1 id1 Node id range start
# $2 id2 Node id range end
##
cdepl_app_etcd_start()
{
	local node_range_start=$1
	local node_range_end=$2

	if [ "$node_range_end" ]; then
		local pids=""
		
		for node in $(seq "$node_range_start" "$node_range_end"); do
			__cdepl_app_etcd_start "$node" "$node_range_start" "$node_range_end" &
			pids="$pids $!"
		done

		wait $pids
	else
		__cdepl_app_etcd_start "$node_range_start"
    fi
}

##
# Start a consul (server) instance on the target node.
#
# $1 node node id
##
__cdepl_app_etcd_start()
{
	local node=$1
	local node_range_start=$2
	local node_range_end=$3

    local server_list=""

    for n in $(seq "$node_range_start" "$node_range_end"); do
        server_list="${server_list}node$n=http://$(cdepl_cluster_resolve_node_to_ip $n):$__ETCD_PEER_PORT,"
    done

	local ip="$(cdepl_cluster_resolve_node_to_ip ${node})"

	local logfile="${__ETCD_OUT_PATH}/node${node}.log"

	# Delete etcd's previous data directory
	util_log "[$node][etcd] Deleting etcd data directory"
	cdepl_cluster_node_cmd "$node" "rm -rf $__ETCD_DATA_DIR"

	cdepl_cluster_node_cmd $node "mkdir -p $__ETCD_DATA_DIR"

	local cmd="nohup ${__ETCD_PATH}/etcd --name node$node --initial-cluster $server_list --initial-cluster-state new --listen-peer-urls http://$ip:$__ETCD_PEER_PORT --listen-client-urls http://$ip:$__ETCD_CLIENT_PORT --advertise-client-urls http://$ip:$__ETCD_CLIENT_PORT --data-dir=${__CONSUL_DATA_DIR} >> $logfile 2>&1 &"

	cmd=""

	util_log "[$node][etcd] Starting etcd: cmd=$cmd"

    cdepl_cluster_node_cmd $node "$cmd"
    
	if [ "$?" != "0" ]; then
		util_log_error_and_exit "[$node][etcd] Starting failed, also check logfile $logfile"
	fi
}

##
# Wait for etcd (server) instances to be started
#
# $1 id1 Node id with started etcd instance range start
# $2 id2 Node id range end
##
cdepl_app_etcd_wait_started()
{
	local node_range_start=$1
	local node_range_end=$2

	if [ "$node_range_end" ]; then
		local pids=""

		for node in $(seq "$node_range_start" "$node_range_end"); do
			__cdepl_app_etcd_wait_started "$node" &
			pids="$pids $!"
		done

		wait $pids
	else
		__cdepl_app_etcd_wait_started "$node_range_start"
	fi
}

##
# Wait for a started etcd (server) instance to be started
#
# $1 node Target node id with started etcd (server) instance
##
__cdepl_app_etcd_wait_started()
{
	local node=$1

	local logfile=${__ETCD_OUT_PATH}/node${node}.log

	util_log "[$node][etcd] Waiting for startup"

	while true; do
		echo -n "."

		local success_started=$(cdepl_cluster_node_cmd $node "cat "$logfile" 2> /dev/null | grep 'Starting Consul agent'")
		local success_running=$(cdepl_cluster_node_cmd $node "cat "$logfile" 2> /dev/null | grep 'Consul agent running!'")
		local fail_file=$(cdepl_cluster_node_cmd $node "cat "$logfile" 2> /dev/null | grep 'No such file or directory'")
		local fail_pid=$(cdepl_cluster_node_cmd $node "cat "$logfile" 2> /dev/null | grep 'FAILED TO WRITE PID'")
		local fail_started=$(cdepl_cluster_node_cmd $node "cat "$logfile" 2> /dev/null | grep 'SERVER DID NOT START'")

		if [ "$success_started" != "" ] || [ "$success_running" != "" ]; then
			local pid=$(cdepl_cluster_node_cmd $node "pgrep -f 'etcd'")

			echo ""

			if [ "$pid" = "" ]; then
				util_log_error_and_exit "[$node][etcd] Could not find started process"
			fi

			util_log "[$node][etcd] Started (pid: $pid)"

			break
		elif [ "$fail_file" != "" -o "$fail_pid" != "" -o "$fail_started" != "" ] ; then
			echo ""
			util_log_error_and_exit "[$node][etcd] Could not be started. See log file $logfile"
		fi

		sleep 1.0
	done
}

##
# Cleanup any still running or remaining/crashed instances on the target node
#
# $1 Target node id (or start node id of range if second parameter provided)
# $2 Optional: Node id range end (including) and first parameter is interpreted
#    as range start (including)
##
cdepl_app_etcd_cleanup()
{
	local node_range_start=$1
	local node_range_end=$2

	if [ "$node_range_end" ]; then
		local pids=""

		for node in $(seq $node_range_start $node_range_end); do
			__cdepl_app_etcd_cleanup $node &
			pids="$pids $!"
		done

		wait $pids
	else
		__cdepl_app_etcd_cleanup $node_range_start
	fi
}

__cdepl_app_etcd_get_instance_running_pid()
{
	local node=$1

	echo "$(cdepl_cluster_node_cmd $node "pgrep -f 'etcd'")"
}

__cdepl_app_etcd_cleanup()
{
	local node=$1

	util_log "[$node][etcd] Cleanup..."

	local pid=$(cdepl_cluster_node_cmd $node "pgrep -f 'etcd'")

	if [ "$pid" != "" ]; then
		cdepl_cluster_node_cmd $node "kill -9 $pid > /dev/null 2>&1"

		if [ "$?" != "0" ]; then
			util_log_warn "[$node][etcd] Killing $pid failed, consul might stay alive"
		else
			util_log "[$node][etcd] Killed (pid: $pid)"
		fi
	fi
}