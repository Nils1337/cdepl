#!/bin/bash

#
# Comprehensive benchmark for DXNet
#

# Adjust parameters according to your setup
TOTAL_NODES=4
NETWORK_TYPE="ib"

# Cluster type and user selected
CLUSTER_TYPE="hhubs"
CLUSTER_USER="nothaas"

# Output path for log files, config files depending
# on the application deployed
OUT_PATH="/home/${CLUSTER_USER}/scratch"

# DXNET parameters
DXNET_PATH="/home/${CLUSTER_USER}/dxnet"

RESULT_ARCHIVES_OUT_PATH="/home/${CLUSTER_USER}/scratch/dxnet_results"

benchmark()
{
	local workload=$1
	local total_nodes=$2
	local msg_count=$3
	local msg_size=$4
	local threads=$5
	local msg_handler=$6

	echo "##### Benchmark: $workload $total_nodes $msg_count $msg_size $threads $msg_handler"

	# Initialize dxnet deployment
	cdepl_app_dxnet_init $DXNET_PATH
	
	# Kill any still running instances from previous deployments
	for i in $(seq 0 $((total_nodes - 1))); do
		cdepl_app_dxnet_node_cleanup $i
	done

	# Parameters
	depl_app_dxnet_workload $workload
	depl_app_dxnet_msg_count $(($msg_count / ($total_nodes - 1)))
	depl_app_dxnet_msg_size $msg_size

	# All to all
	# On two nodes only -> point to point
	for i in $(seq 0 $((total_nodes - 1))); do
		local targets=""
		
		for j in $(seq 0 $((total_nodes - 1))); do
			if [ "$i" != "$j" ]; then
				targets="$targets $j"
			fi
		done

		cdepl_app_dxnet_node_send_targets $i $targets
	done

    # Set network type
	depl_app_dxnet_network $NETWORK_TYPE

	# Set individual parameters for nodes
	for i in $(seq 0 $((total_nodes - 1))); do
		cdepl_app_dxnet_node_send_threads $i $threads
		cdepl_app_dxnet_node_message_handler $i $msg_handler

		#cdepl_app_dxnet_remote_debug $i $((11110 + i))

		if [ "$NETWORK_TYPE" = "ib" ]; then
			cdepl_app_dxnet_run_as_sudo $i
		fi
	done

	# Start all instances
	for i in $(seq 0 $((total_nodes - 1))); do
		cdepl_app_dxnet_start_node $i
	done

	# Wait for all instances to finish, this also checks for runtime errors
	for i in $(seq 0 $((total_nodes - 1))); do
		cdepl_app_dxnet_node_wait_finished $i
	done

	# Print results
	for i in $(seq 0 $((total_nodes - 1))); do
		printf "######################\nResults node $i\n"
		cdepl_app_dxnet_node_get_results $i
		printf "######################\n"
	done

	# Kill any leftovers
	for i in $(seq 0 $((total_nodes - 1))); do
		cdepl_app_dxnet_node_cleanup $i
	done

	# Pack results and move
	cdepl_deploy_archive_out_path "dxnet_${workload}_${total_nodes}_${msg_size}_${threads}_${msg_handler}" $RESULT_ARCHIVES_OUT_PATH

	# Reset output path for next benchmark call
	cdepl_deploy_out_path $OUT_PATH
}

cdepl_script_cluster_node_setup()
{
	# Set the log level to output debug info
	util_log_set_level "$UTIL_LOG_LEVEL_DEBUG"

	# Init the cluster environment to deploy to
	cdepl_cluster_init $CLUSTER_TYPE $CLUSTER_USER

	# Load application modules of apps you want to deploy
	cdepl_cluster_app_load "dxnet"

	# Alloc total number of nodes for this deployment
	cdepl_cluster_node_alloc $TOTAL_NODES

	# Walltime for your deployment, might be ignored depending
	# on cluster environment selected
	cdepl_cluster_walltime "01:00:00"

	# Reserve all nodes exclusive (all resources available)
	for i in $(seq 0 $((TOTAL_NODES - 1))); do
		cdepl_cluster_node_excl $i
	done

	# Set our output path for log files and configurations 
	# for the applications deployed
	cdepl_deploy_out_path $OUT_PATH
}

cdepl_script_environment_setup()
{
	for i in $(seq 0 $((TOTAL_NODES - 1))); do
		cdepl_cluster_resolve_dependency $i "java" "1.8"
	done
}

cdepl_script_deploy()
{
	cdepl_cluster_login_cmd "mkdir -p $RESULT_ARCHIVES_OUT_PATH"

	local msg_count=100000000
	local msg_handler=8
	local sizes="1 2 4 8 16 32 64 128 256 512 1024 2048 4096"
	local threads="1 2 4 8 16 32 64 128"

	# Messages, single threaded benchmark
	for size in $sizes; do
		for node_count in $(seq 2 $TOTAL_NODES); do
			benchmark 0 $node_count $msg_count $size 1 2
		done
	done

	# Messages multi threaded benchmark
	for thread in $threads; do
		for size in $sizes; do
			for node_count in $(seq 2 $TOTAL_NODES); do
				benchmark 0 $node_count $msg_count $size $thread $msg_handler
			done
		done
	done

	# Request-response multi threaded benchmark

	# TODO scale message count with number of threads, otherwise it takes ages to complete single threaded

	for thread in $threads; do
		for size in $sizes; do
			for node_count in $(seq 2 $TOTAL_NODES); do
				benchmark 2 $node_count $msg_count $size $thread $msg_handler
			done
		done
	done

	# TODO Test many small msgs long running + many huge msgs long running to test and detect overflows of states in code
	# -> separate test script

	# Done
	echo "Archived results can be found in $RESULT_ARCHIVES_OUT_PATH"
}

cdepl_script_cleanup()
{
	# Kill any leftovers
	for i in $(seq 0 $((TOTAL_NODES - 1))); do
		cdepl_app_dxnet_node_cleanup $i
	done
}
